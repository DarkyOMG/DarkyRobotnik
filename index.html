<!doctype html>
<!-- HTML Webpage for own alerts. Only needed if you want to fire your own alerts and clips.-->
<html>

<head>
   <title>DarkyRobotnik Alerts</title>
   <link rel="icon" href="/images/favicon.ico" sizes="any"><!-- 32×32 -->
   <link rel="stylesheet" href="styles.css">
</head>

<body>
   <figure>
      <audio src="Follow.wav"></audio>
   </figure>
   <div id="wrapper">
      <img id="animim">
  </div>
  <div id="clip" class="clip">
     <iframe
      src=""
      height="360px"
      width="640px"
      style="position: absolute;"
      style="border:2px solid black;"
      allowfullscreen>
  </iframe>
  
  <h1 id="clipheader">Darky Raidet uns!</h1>
  </div>
   <div id="animthing" class="animthing">
      <figure>
         <img src="images/Follow.gif" alt="Couldn't find image">
         <p>WTFDarky stürmt den Hörsaal mit 23 wilden Studierenden!</p>
      </figure>
   </div>

   <div class="footer" id="footer">
      <p>Footer</p>
    </div>
</body>
<script type="text/javascript">
   // Get all relevant elements.
   const audioelem = document.querySelector("audio");
   const imageelem = document.getElementById("animthing");
   const animimagewrapper = document.getElementById("wrapper");
   const animim = document.getElementById("animim");
   const textelem = document.querySelector("p");
   const clipdiv = document.getElementById("clip");
   const clipheader = document.getElementById("clipheader");
   const footer = document.getElementById("footer");
   // This list is used for overlaid audioelements.
   animimagewrapper.style.display = "none";
   animim.src = "";
   let audioelemlist = []
   let audioqueue = []
   let isFiringClip = false
   let alertqueue = []
   let isFiringAlert = false
   // Start the websocket to recieve events fired by bot.js
   WebSocketTest();
   function TriggerFollow(username) {
      imageelem.src = 'images/Follow.gif';
      audioelem.src = 'clips/Follow.wav';
      textelem.innerText = `${username} ist nun immatrikuliert!`;
      audioelem.play();
      // restart the animation
      imageelem.classList.remove("animthing");
      setTimeout(function () {
         imageelem.classList.add("animthing");
      }, 0);
   }
   function TriggerRaid(raidername, viewercount) {
      textelem.innerText = `${raidername} stürmt den Hörsaal mit ${viewercount} wilden Studierenden!`;
      imageelem.src = 'images/Raid.png';
      audioelem.src = 'clips/Raid.wav';
      audioelem.play();
      // restart the animation
      imageelem.classList.remove("animthing");
      setTimeout(function () {
         imageelem.classList.add("animthing");
      }, 0);
   }
   function HandleClip(raidername, clipslug, length){
      clipdiv.style.display = "flex";
      clipheader.innerText = `${raidername} ist da!`;
      document.querySelector("iframe").src=`https://clips.twitch.tv/embed?clip=${clipslug}&parent=muskatnuss.duckdns.org&autoplay=true&preload=auto`
      setTimeout(ResetClipDiv, length);
   }
   function ResetClipDiv(){
      clipdiv.style.display = "none";
   }
   function HandleAlerts() {
      isFiringAlert = true
      if(isFiringClip){
         isFiringAlert = false;
         setTimeout(HandleAlerts, 8500);
         return;
      }
      if (alertqueue.length > 0) {
         var current = alertqueue.shift()
         if (current['type'] == "follow") {
            TriggerFollow(current['username'])
         }
         if (current['type'] == "raid") {
            TriggerRaid(current['raidername'], current['viewercount'])
         }
         setTimeout(HandleAlerts, 8500);
      } else {
         isFiringAlert = false
      }
   }
   function PlaySingleClip(clipname) {

      audioelem.src = 'clips/' + clipname + '.wav';
      audioelem.play();
   }
   function HandleClips() {
      isFiringClip = true
      animim.src = "";
      animimagewrapper.style.display = "none";
      if(isFiringAlert){
         isFiringClip = false;
         setTimeout(HandleClips, 8500);
         return;
      }
      if (audioqueue.length > 0) {
         var current = audioqueue.shift()
         PlaySingleClip(current[1])
         if(current[2]){
            animim.src = 'images/'+current[1]+'.gif';
            animimagewrapper.style.display = "block";
         }
         setTimeout(HandleClips, parseInt(current[0])*1000);
      } else {
         isFiringClip = false;
      }
   }
   function WebSocketTest() {
      // Check if your browers allows websockets
      if ("WebSocket" in window) {
         // Let us open a web socket
         var ws = new WebSocket("wss://muskatnuss.duckdns.org");

         ws.onopen = function () {
            console.log("Connected to server!")
            alert("Connection is open!")
         };

         // Handle any received message, such as raid or follow-alerts.
         ws.onmessage = function (evt) {
            var received_msg = evt.data;


            if(received_msg.slice(0,2) == 'so'){
               var parameters = received_msg.split(" "); 
               HandleClip(parameters[1],parameters[2],parameters[3]);
            }
            // Handle follows
            if (received_msg.slice(0, 6) == 'follow') {
               var username = received_msg.slice(6);
               alertqueue.push({ type: "follow", username: username })
            }

            // Handle raids
            if (received_msg.slice(0, 4) == 'raid') {
               const regex = /raid(?<name>\S+):(?<viewers>\d+)/;
               let result = received_msg.match(regex);
               var raidername = result['groups']['name'];
               var viewercount = result['groups']['viewers'];
               alertqueue.push({ type: "raid", raidername: raidername, viewercount: viewercount })
            }

            if (!isFiringAlert) {
               HandleAlerts()
            }

            // List for certain rewards. Only needed for filtering.
            let tones = ["A", "H", "C", "D", "E", "F", "G"]

            // I myself use soundsclips so a possible event could be the call of clip. Handling clip-calls
            if (received_msg.slice(0, 4) == 'clip' || received_msg.slice(0, 4) == 'anim') {
               // On certain clip-calls, we use overlaiable audioelements. In my example these are the clap and the tones-clips.
               // If a normal clip is called, just play the clip and be done with it.
                  audioqueue.push([received_msg.slice(4,7),received_msg.slice(6),received_msg.slice(0, 4) == 'anim'])
            }
            if (received_msg.slice(0,4) == "over") {
                  // For this, we create a new audio-element for each call and play the given soundclip. Notice that all files are called like the event.
                  var tempaudio = document.createElement("audio");
                  tempaudio.src = 'clips/' + received_msg.slice(6) + '.wav';
                  // Play the sound and remove it's audioelement after 2 seconds (could be longer, doesn't really matter) to not fill up the ram.
                  tempaudio.play();
                  setTimeout(function () {
                     tempaudio.remove();
                  }, 2000);
            }
            if(received_msg.slice(0,7) == "rainbow"){
               var tempcolor = document.createElement("div");
               tempcolor.classList.add("child");
               tempcolor.style.backgroundColor = received_msg.slice(7);
               footer.appendChild(tempcolor);
               alert("RAINBOW");
            }

            if (!isFiringClip) {
               HandleClips()
            }
         };
         ws.onclose = function () {
            // websocket is closed.
            alert("Connection is closed!");
         };
      } else {
         // The browser doesn't support WebSocket
         alert("WebSocket NOT supported by your Browser!");
      }


   }
</script>

</html>